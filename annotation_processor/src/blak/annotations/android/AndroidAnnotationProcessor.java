/**
 * Copyright (C) 2010-2013 eBusiness Information, Excilys Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed To in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package blak.annotations.android;

import blak.annotations.EActivity;
import blak.annotations.ViewById;
import blak.annotations.utils.ALog;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import java.io.IOException;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

@SupportedSourceVersion(SourceVersion.RELEASE_6)
public class AndroidAnnotationProcessor extends AbstractProcessor {
    private final ErrorHelper errorHelper = new ErrorHelper();

    private Set<String> supportedAnnotationNames;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);

        Messager messager = processingEnv.getMessager();
        messager.printMessage(Diagnostic.Kind.NOTE, "Starting AndroidAnnotations annotation processing");
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {

        try {
            processThrowing(annotations, roundEnv);
        } catch (ProcessingException e) {
            handleException(annotations, roundEnv, e);
        } catch (Exception e) {
            handleException(annotations, roundEnv, new ProcessingException(e, null));
        }
        return true;
    }

    private void processThrowing(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) throws ProcessingException, Exception {
        if (nothingToDo(annotations, roundEnv)) {
            return;
        }

        AnnotationElementsHolder extractedModel = extractAnnotations(annotations, roundEnv);

        ModelProcessor.ProcessResult processResult = processAnnotations(extractedModel);

        generateSources(processResult);
    }

    private boolean nothingToDo(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        return roundEnv.processingOver() || annotations.size() == 0;
    }

    private AnnotationElementsHolder extractAnnotations(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        ModelExtractor modelExtractor = new ModelExtractor();
        AnnotationElementsHolder extractedModel = modelExtractor.extract(annotations, getSupportedAnnotationTypes(), roundEnv);

        ALog.print(processingEnv, extractedModel.getAllElements());

        return extractedModel;
    }

    private ModelProcessor.ProcessResult processAnnotations(AnnotationElements validatedModel) throws ProcessingException, Exception {
        ModelProcessor modelProcessor = buildModelProcessor(validatedModel);
        ModelProcessor.ProcessResult processResult = modelProcessor.process(validatedModel);
        return processResult;
    }

    private ModelProcessor buildModelProcessor(AnnotationElements validatedModel) {
        ModelProcessor modelProcessor = new ModelProcessor();
        modelProcessor.register(new EActivityProcessor(processingEnv));
        modelProcessor.register(new ViewByIdProcessor(processingEnv));
        return modelProcessor;
    }

    private void generateSources(ModelProcessor.ProcessResult processResult) throws IOException {
        Messager messager = processingEnv.getMessager();
        messager.printMessage(Diagnostic.Kind.NOTE, "Number of files generated by AndroidAnnotations: " + processResult.codeModel.countArtifacts());
        CodeModelGenerator modelGenerator = new CodeModelGenerator(processingEnv.getFiler(), messager);
        modelGenerator.generate(processResult);
    }

    private void handleException(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv, ProcessingException e) {
        String errorMessage = errorHelper.getErrorMessage(processingEnv, e);

        Messager messager = processingEnv.getMessager();
        messager.printMessage(Diagnostic.Kind.ERROR, errorMessage);

		/*
         * Printing exception as an error on a random element. The exception is
		 * not related to this element, but otherwise it wouldn't show up in
		 * eclipse.
		 */

        Iterator<? extends TypeElement> iterator = annotations.iterator();
        if (iterator.hasNext()) {
            Element element = roundEnv.getElementsAnnotatedWith(iterator.next()).iterator().next();
            messager.printMessage(Diagnostic.Kind.ERROR, errorMessage, element);
        }
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        if (supportedAnnotationNames == null) {
            Class<?>[] annotationClassesArray = { //
                    //
                    EActivity.class, //
                    ViewById.class, //
            };

            Set<String> set = new HashSet<String>(annotationClassesArray.length);
            for (Class<?> annotationClass : annotationClassesArray) {
                set.add(annotationClass.getName());
            }
            supportedAnnotationNames = Collections.unmodifiableSet(set);
        }
        return supportedAnnotationNames;
    }
}
